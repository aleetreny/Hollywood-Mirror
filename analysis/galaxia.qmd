---
title: "La Galaxia del Cine"
subtitle: "Análisis geométrico del espacio latente de ~2.600 películas"
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: true
    code-tools: true
jupyter: python3
---

## Introducción

Este documento recorre el **análisis geométrico** del proyecto Hollywood Mirror: partimos de la matriz de embeddings de las películas, reducimos dimensiones con **UMAP**, visualizamos la "galaxia" con **Plotly** y extraemos conclusiones sobre agrupaciones y similitudes.

**Pipeline previo (ya ejecutado):**

1. **Parsing:** JSON por película → texto limpio (solo `heading` y `speaker/title`).
2. **Embeddings:** Chunking (~300 palabras, 10% overlap) → modelo `all-mpnet-base-v2` → mean pooling por película → matriz `[N, 768]`.

---

## Paso 1: Configuración y carga de embeddings

Añadimos la raíz del proyecto al path para importar `src` y cargamos la matriz y los títulos guardados.

```{python}
#| label: setup
from pathlib import Path
import numpy as np
import pandas as pd

# Raíz del repo: Quarto puede ejecutar desde raíz o desde analysis/
REPO = Path(".").resolve()
if not (REPO / "data").exists():
    REPO = REPO.parent
processed = REPO / "data" / "processed"
embeddings_npy = processed / "movie_embeddings.npy"
embeddings_txt = processed / "movie_embeddings.txt"
if not embeddings_npy.exists() or not embeddings_txt.exists():
    raise FileNotFoundError(
        "Faltan movie_embeddings.npy y/o movie_embeddings.txt. "
        "Desde la raíz del proyecto ejecuta: python -m src.embeddings mpnet"
    )

# Cargamos los embeddings precalculados (sin depender de sentence_transformers)
matrix = np.load(embeddings_npy)
with open(embeddings_txt, encoding="utf-8") as f:
    titles = [line.strip() for line in f if line.strip()]
print(f"Matriz: {matrix.shape} (películas × dimensiones)")
print(f"Títulos: {len(titles)}")
```

---

## Paso 2: Reducción de dimensiones con UMAP

UMAP (Uniform Manifold Approximation and Projection) proyecta los vectores de 768 dimensiones a 2D preservando la estructura de vecindad: películas cercanas en el espacio original quedan cercanas en el plano.

```{python}
#| label: umap
import umap

reducer = umap.UMAP(
    n_components=2,
    n_neighbors=15,
    min_dist=0.1,
    metric="cosine",
    random_state=42,
)
coords_2d = reducer.fit_transform(matrix)
print(f"Coordenadas 2D: {coords_2d.shape}")
```

---

## Paso 3: Visualización interactiva — La Galaxia del Cine

Cada punto es una película; la posición refleja similitud semántica (estilo narrativo, tono, temas) según los embeddings.

```{python}
#| label: plotly-galaxy
import plotly.express as px

df_plot = pd.DataFrame({
    "x": coords_2d[:, 0],
    "y": coords_2d[:, 1],
    "película": titles,
})

fig = px.scatter(
    df_plot, x="x", y="y",
    hover_data={"película": True, "x": False, "y": False},
    title="Galaxia del Cine — cada punto es una película",
    labels={"x": "UMAP 1", "y": "UMAP 2"},
)
fig.update_traces(marker=dict(size=4, opacity=0.6))
fig.update_layout(height=600)
fig.show()
```

---

## Paso 4: Análisis de clusters

Agrupamos las películas en clusters sin etiquetas previas (solo a partir del texto). Así vemos si géneros o estilos se agrupan de forma natural.

```{python}
#| label: clusters
from sklearn.cluster import KMeans

n_clusters = 8
kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
labels = kmeans.fit_predict(matrix)

df_plot["cluster"] = labels.astype(str)
fig2 = px.scatter(
    df_plot, x="x", y="y", color="cluster",
    hover_data={"película": True},
    title=f"Clusters (K-means, k={n_clusters}) — agrupación por estilo narrativo",
    labels={"x": "UMAP 1", "y": "UMAP 2"},
)
fig2.update_traces(marker=dict(size=4, opacity=0.7))
fig2.update_layout(height=600)
fig2.show()
```

---

## Paso 5: Métricas — Similitud entre películas

Calculamos la **similitud del coseno** entre películas. Ejemplo: buscar las más cercanas a una película dada (p. ej. *Inception*).

```{python}
#| label: similitud
from sklearn.metrics.pairwise import cosine_similarity

def top_similares(titles_list, matrix, query_title, k=10):
    """Top k películas más similares a query_title."""
    try:
        idx = titles_list.index(query_title)
    except ValueError:
        # búsqueda parcial
        candidatos = [i for i, t in enumerate(titles_list) if query_title.lower() in t.lower()]
        if not candidatos:
            return None
        idx = candidatos[0]
    vec = matrix[idx : idx + 1]
    sim = cosine_similarity(matrix, vec).ravel()
    orden = np.argsort(sim)[::-1]
    return [(titles_list[i], sim[i]) for i in orden[:k]]

# Ejemplo: películas más parecidas a "Inception"
ejemplo = "Inception_1375666"
top = top_similares(titles, matrix, ejemplo, k=10)
if top:
    print("Películas más similares a Inception (por estilo narrativo):")
    for tit, s in top:
        print(f"  {s:.3f}  {tit}")
```

---

## Paso 6: Distancias dentro de una filmografía

Podemos comparar la cercanía entre películas del mismo director (ej. Nolan): si el espacio captura estilo, sus películas deberían estar relativamente agrupadas.

```{python}
#| label: filmografia
# Ejemplo: todas las películas que contengan "Nolan" en el título (o buscar por director si tuviéramos metadatos)
nolan_like = [t for t in titles if "Nolan" in t or "Inception" in t or "Interstellar" in t or "Dark Knight" in t or "Prestige" in t]
if nolan_like:
    print("Algunas películas tipo Nolan en el dataset:", nolan_like[:10])
# En un dataset con metadatos de director, aquí filtraríamos por director y pintaríamos solo esos puntos.
```

---

## Conclusiones

1. **Espacio latente:** Los embeddings (768 dims con mpnet) codifican estilo narrativo, tono y contenido. Películas similares en ese espacio son cercanas en el scatter UMAP.

2. **Galaxia:** La visualización 2D permite explorar vecindades: qué películas “rodean” a una dada y si los clusters coinciden con géneros o corrientes (eso depende del corpus y de \(k\) en K-means).

3. **Similitud:** La similitud del coseno entre vectores es la base del buscador (Streamlit): el usuario escribe un texto, se embeda y se compara con esta misma matriz para obtener el Top 5.

4. **Limitaciones:** UMAP y los clusters dependen de hiperparámetros (\(n\_neighbors\), \(min\_dist\), \(k\)). No tenemos etiquetas de género en los datos; las agrupaciones son puramente textuales/semánticas.

5. **Siguiente paso:** Con la app Streamlit se puede llevar este mismo espacio a una interfaz donde el usuario introduce un fragmento y ve su posición en la galaxia y las películas más afines.
